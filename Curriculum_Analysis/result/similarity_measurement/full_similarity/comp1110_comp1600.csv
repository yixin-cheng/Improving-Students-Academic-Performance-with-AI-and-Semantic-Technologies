score,s1,s2
0.8313,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.","The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8580,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.","Inheritance, polymorphism, and parametric types are taught, as well as concepts such as boxing and auto boxing."
0.8623,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.",This course introduces students to the fundamentals of software development with a substantial group software project at its center.
0.8750,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.","Deliver and evaluate basic technical documents, presentations, and group interactions, using appropriate tools."
0.8789,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.","The foundations of software engineering including: major development paradigms (such as big plan up front, agile, and formal methods), risk are introduced."
0.8795,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.","Students will be introduced to an industrial strength object oriented programming language, extending their understanding of the imperative programming paradigm with a solid grounding in object oriented programming."
0.8814,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.","Students will extend their understanding of software productivity tools, using revision control for group work, and be introduced to test-driven development as an integral part of software construction."
0.8833,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.","Apply basic algorithmic analysis to simple algorithms; use appropriate algorithmic approaches to solve problems (brute-force, divide-and-conquer, recursive backtracking, heuristic)."
0.8881,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.",The important role of standard libraries and their collection types will be emphasized.  GUI programming will be introduced.
0.8962,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.","Develop, understand, test, and evolve substantial programs using a modern IDE, and associated configuration tools; understand common coding errors and how to avoid them; practice fundamental defensive programming; perform individual and team program reviews; use established design principles to organize a software system."
0.9020,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.","Distinguish language definition from implementation, syntax and parsing from semantics and evaluation, understand how program state maps to memory (globals, local, heap), and understand the implications of heap reachability for memory management."
0.9035,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.","Use, implement, and evaluate fundamental data structures and associated algorithms; create, implement, debug, and evaluate algorithms for solving substantial problems, including recursively, using divide-and-conquer, and via decomposition; implement an abstract data type."
0.9037,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.","Major foci are data structures, object oriented programming, and an introduction to software engineering."
0.9061,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.","Apply fundamental programming concepts, using an object oriented programming language, to solve substantial problems."
0.9160,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.","Understand the basics of event-driven programming, and its use in constructing GUIs"
0.9241,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.","The course includes a deeper treatment of data structures, using hash tables, trees and lists, which are used to provide concrete implementations of abstract library collection types."
0.9267,"This course presents some formal notations that are commonly used for the description of computation and of computing systems, for the specification of software and for mathematically rigorous arguments about program properties.",The theory of data structures and their time and space complexity will thus be tied to the practice of using standard collections such as those offered by object oriented languages.
0.8498,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.","The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8777,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.","Deliver and evaluate basic technical documents, presentations, and group interactions, using appropriate tools."
0.8809,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.",This course introduces students to the fundamentals of software development with a substantial group software project at its center.
0.8919,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.","Develop, understand, test, and evolve substantial programs using a modern IDE, and associated configuration tools; understand common coding errors and how to avoid them; practice fundamental defensive programming; perform individual and team program reviews; use established design principles to organize a software system."
0.8925,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.","Students will extend their understanding of software productivity tools, using revision control for group work, and be introduced to test-driven development as an integral part of software construction."
0.8952,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.",The important role of standard libraries and their collection types will be emphasized.  GUI programming will be introduced.
0.8956,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.","Students will be introduced to an industrial strength object oriented programming language, extending their understanding of the imperative programming paradigm with a solid grounding in object oriented programming."
0.8957,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.","The foundations of software engineering including: major development paradigms (such as big plan up front, agile, and formal methods), risk are introduced."
0.9036,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.","Understand the basics of event-driven programming, and its use in constructing GUIs"
0.9082,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.","Apply fundamental programming concepts, using an object oriented programming language, to solve substantial problems."
0.9111,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.","Inheritance, polymorphism, and parametric types are taught, as well as concepts such as boxing and auto boxing."
0.9190,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.","Major foci are data structures, object oriented programming, and an introduction to software engineering."
0.9229,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.","Apply basic algorithmic analysis to simple algorithms; use appropriate algorithmic approaches to solve problems (brute-force, divide-and-conquer, recursive backtracking, heuristic)."
0.9233,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.","Distinguish language definition from implementation, syntax and parsing from semantics and evaluation, understand how program state maps to memory (globals, local, heap), and understand the implications of heap reachability for memory management."
0.9285,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.","Use, implement, and evaluate fundamental data structures and associated algorithms; create, implement, debug, and evaluate algorithms for solving substantial problems, including recursively, using divide-and-conquer, and via decomposition; implement an abstract data type."
0.9297,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.",The theory of data structures and their time and space complexity will thus be tied to the practice of using standard collections such as those offered by object oriented languages.
0.9452,"The following areas of study constitute the backbone of the course. Predicate calculus and natural deduction, inductive definitions of data types as a basis for recursive functions and structural induction, formal language theory (particularly regular expressions, finite state machines and context free grammars), and specification languages.","The course includes a deeper treatment of data structures, using hash tables, trees and lists, which are used to provide concrete implementations of abstract library collection types."
0.8560,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).","The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8659,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).",This course introduces students to the fundamentals of software development with a substantial group software project at its center.
0.8746,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).",The important role of standard libraries and their collection types will be emphasized.  GUI programming will be introduced.
0.8812,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).","Students will extend their understanding of software productivity tools, using revision control for group work, and be introduced to test-driven development as an integral part of software construction."
0.8840,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).","Students will be introduced to an industrial strength object oriented programming language, extending their understanding of the imperative programming paradigm with a solid grounding in object oriented programming."
0.8861,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).","The foundations of software engineering including: major development paradigms (such as big plan up front, agile, and formal methods), risk are introduced."
0.8874,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).","Develop, understand, test, and evolve substantial programs using a modern IDE, and associated configuration tools; understand common coding errors and how to avoid them; practice fundamental defensive programming; perform individual and team program reviews; use established design principles to organize a software system."
0.8876,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).","Distinguish language definition from implementation, syntax and parsing from semantics and evaluation, understand how program state maps to memory (globals, local, heap), and understand the implications of heap reachability for memory management."
0.8893,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).","Deliver and evaluate basic technical documents, presentations, and group interactions, using appropriate tools."
0.8909,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).","Understand the basics of event-driven programming, and its use in constructing GUIs"
0.8922,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).","Major foci are data structures, object oriented programming, and an introduction to software engineering."
0.9023,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).","Inheritance, polymorphism, and parametric types are taught, as well as concepts such as boxing and auto boxing."
0.9071,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).",The theory of data structures and their time and space complexity will thus be tied to the practice of using standard collections such as those offered by object oriented languages.
0.9114,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).","Use, implement, and evaluate fundamental data structures and associated algorithms; create, implement, debug, and evaluate algorithms for solving substantial problems, including recursively, using divide-and-conquer, and via decomposition; implement an abstract data type."
0.9122,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).","Apply fundamental programming concepts, using an object oriented programming language, to solve substantial problems."
0.9128,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).","Apply basic algorithmic analysis to simple algorithms; use appropriate algorithmic approaches to solve problems (brute-force, divide-and-conquer, recursive backtracking, heuristic)."
0.9253,"Apply the concepts of standard mathematical logic to produce proofs or refutations of well-formed propositions or arguments phrased in English or in a variety of formal notations (first order logic, discrete mathematics or Hoare Logic).","The course includes a deeper treatment of data structures, using hash tables, trees and lists, which are used to provide concrete implementations of abstract library collection types."
0.7768,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.","The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.7957,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.",This course introduces students to the fundamentals of software development with a substantial group software project at its center.
0.8024,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.","Deliver and evaluate basic technical documents, presentations, and group interactions, using appropriate tools."
0.8048,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.","Students will extend their understanding of software productivity tools, using revision control for group work, and be introduced to test-driven development as an integral part of software construction."
0.8064,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.","The foundations of software engineering including: major development paradigms (such as big plan up front, agile, and formal methods), risk are introduced."
0.8135,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.",The important role of standard libraries and their collection types will be emphasized.  GUI programming will be introduced.
0.8219,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.","Major foci are data structures, object oriented programming, and an introduction to software engineering."
0.8224,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.","Students will be introduced to an industrial strength object oriented programming language, extending their understanding of the imperative programming paradigm with a solid grounding in object oriented programming."
0.8308,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.","Develop, understand, test, and evolve substantial programs using a modern IDE, and associated configuration tools; understand common coding errors and how to avoid them; practice fundamental defensive programming; perform individual and team program reviews; use established design principles to organize a software system."
0.8350,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.","Understand the basics of event-driven programming, and its use in constructing GUIs"
0.8354,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.","Inheritance, polymorphism, and parametric types are taught, as well as concepts such as boxing and auto boxing."
0.8504,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.","Apply fundamental programming concepts, using an object oriented programming language, to solve substantial problems."
0.8667,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.","Distinguish language definition from implementation, syntax and parsing from semantics and evaluation, understand how program state maps to memory (globals, local, heap), and understand the implications of heap reachability for memory management."
0.8676,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.",The theory of data structures and their time and space complexity will thus be tied to the practice of using standard collections such as those offered by object oriented languages.
0.8733,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.","Apply basic algorithmic analysis to simple algorithms; use appropriate algorithmic approaches to solve problems (brute-force, divide-and-conquer, recursive backtracking, heuristic)."
0.8783,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.","The course includes a deeper treatment of data structures, using hash tables, trees and lists, which are used to provide concrete implementations of abstract library collection types."
0.8869,"Given a description of a regular language, either in English, as a regular expression or as a grammar, generate a finite state automaton that recognizes that language. Similarly, given a deterministic or nondeterministic automaton, give a description of the language which it accepts.","Use, implement, and evaluate fundamental data structures and associated algorithms; create, implement, debug, and evaluate algorithms for solving substantial problems, including recursively, using divide-and-conquer, and via decomposition; implement an abstract data type."
0.8238,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.","The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8480,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.",This course introduces students to the fundamentals of software development with a substantial group software project at its center.
0.8577,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.","Students will extend their understanding of software productivity tools, using revision control for group work, and be introduced to test-driven development as an integral part of software construction."
0.8587,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.","Students will be introduced to an industrial strength object oriented programming language, extending their understanding of the imperative programming paradigm with a solid grounding in object oriented programming."
0.8588,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.","Deliver and evaluate basic technical documents, presentations, and group interactions, using appropriate tools."
0.8676,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.","The foundations of software engineering including: major development paradigms (such as big plan up front, agile, and formal methods), risk are introduced."
0.8707,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.","Understand the basics of event-driven programming, and its use in constructing GUIs"
0.8725,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.","Major foci are data structures, object oriented programming, and an introduction to software engineering."
0.8791,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.",The important role of standard libraries and their collection types will be emphasized.  GUI programming will be introduced.
0.8825,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.","Develop, understand, test, and evolve substantial programs using a modern IDE, and associated configuration tools; understand common coding errors and how to avoid them; practice fundamental defensive programming; perform individual and team program reviews; use established design principles to organize a software system."
0.8830,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.","Inheritance, polymorphism, and parametric types are taught, as well as concepts such as boxing and auto boxing."
0.8957,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.","Distinguish language definition from implementation, syntax and parsing from semantics and evaluation, understand how program state maps to memory (globals, local, heap), and understand the implications of heap reachability for memory management."
0.8994,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.","Apply fundamental programming concepts, using an object oriented programming language, to solve substantial problems."
0.9047,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.",The theory of data structures and their time and space complexity will thus be tied to the practice of using standard collections such as those offered by object oriented languages.
0.9136,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.","Apply basic algorithmic analysis to simple algorithms; use appropriate algorithmic approaches to solve problems (brute-force, divide-and-conquer, recursive backtracking, heuristic)."
0.9249,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.","The course includes a deeper treatment of data structures, using hash tables, trees and lists, which are used to provide concrete implementations of abstract library collection types."
0.9281,"Given an inductive definition of a simple data structure, write a recursive definition of a given simple operation on data of that type. Given some such recursively defined operations, prove simple properties of these functions using the appropriate structural induction principle.","Use, implement, and evaluate fundamental data structures and associated algorithms; create, implement, debug, and evaluate algorithms for solving substantial problems, including recursively, using divide-and-conquer, and via decomposition; implement an abstract data type."
0.8388,Prove simple programs correct using Hoare Logic.,"The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8765,Prove simple programs correct using Hoare Logic.,This course introduces students to the fundamentals of software development with a substantial group software project at its center.
0.8795,Prove simple programs correct using Hoare Logic.,"Students will be introduced to an industrial strength object oriented programming language, extending their understanding of the imperative programming paradigm with a solid grounding in object oriented programming."
0.8860,Prove simple programs correct using Hoare Logic.,"Students will extend their understanding of software productivity tools, using revision control for group work, and be introduced to test-driven development as an integral part of software construction."
0.8884,Prove simple programs correct using Hoare Logic.,"Understand the basics of event-driven programming, and its use in constructing GUIs"
0.8891,Prove simple programs correct using Hoare Logic.,The important role of standard libraries and their collection types will be emphasized.  GUI programming will be introduced.
0.8892,Prove simple programs correct using Hoare Logic.,"Distinguish language definition from implementation, syntax and parsing from semantics and evaluation, understand how program state maps to memory (globals, local, heap), and understand the implications of heap reachability for memory management."
0.8902,Prove simple programs correct using Hoare Logic.,"Deliver and evaluate basic technical documents, presentations, and group interactions, using appropriate tools."
0.8909,Prove simple programs correct using Hoare Logic.,"The foundations of software engineering including: major development paradigms (such as big plan up front, agile, and formal methods), risk are introduced."
0.8947,Prove simple programs correct using Hoare Logic.,The theory of data structures and their time and space complexity will thus be tied to the practice of using standard collections such as those offered by object oriented languages.
0.8947,Prove simple programs correct using Hoare Logic.,"Major foci are data structures, object oriented programming, and an introduction to software engineering."
0.8953,Prove simple programs correct using Hoare Logic.,"Develop, understand, test, and evolve substantial programs using a modern IDE, and associated configuration tools; understand common coding errors and how to avoid them; practice fundamental defensive programming; perform individual and team program reviews; use established design principles to organize a software system."
0.9039,Prove simple programs correct using Hoare Logic.,"Use, implement, and evaluate fundamental data structures and associated algorithms; create, implement, debug, and evaluate algorithms for solving substantial problems, including recursively, using divide-and-conquer, and via decomposition; implement an abstract data type."
0.9119,Prove simple programs correct using Hoare Logic.,"Inheritance, polymorphism, and parametric types are taught, as well as concepts such as boxing and auto boxing."
0.9134,Prove simple programs correct using Hoare Logic.,"Apply basic algorithmic analysis to simple algorithms; use appropriate algorithmic approaches to solve problems (brute-force, divide-and-conquer, recursive backtracking, heuristic)."
0.9191,Prove simple programs correct using Hoare Logic.,"The course includes a deeper treatment of data structures, using hash tables, trees and lists, which are used to provide concrete implementations of abstract library collection types."
0.9246,Prove simple programs correct using Hoare Logic.,"Apply fundamental programming concepts, using an object oriented programming language, to solve substantial problems."
0.8501,Design a Turing Machine which will accomplish simple tasks.,"The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8612,Design a Turing Machine which will accomplish simple tasks.,"The foundations of software engineering including: major development paradigms (such as big plan up front, agile, and formal methods), risk are introduced."
0.8658,Design a Turing Machine which will accomplish simple tasks.,"Distinguish language definition from implementation, syntax and parsing from semantics and evaluation, understand how program state maps to memory (globals, local, heap), and understand the implications of heap reachability for memory management."
0.8710,Design a Turing Machine which will accomplish simple tasks.,The important role of standard libraries and their collection types will be emphasized.  GUI programming will be introduced.
0.8721,Design a Turing Machine which will accomplish simple tasks.,"Inheritance, polymorphism, and parametric types are taught, as well as concepts such as boxing and auto boxing."
0.8743,Design a Turing Machine which will accomplish simple tasks.,"Students will be introduced to an industrial strength object oriented programming language, extending their understanding of the imperative programming paradigm with a solid grounding in object oriented programming."
0.8766,Design a Turing Machine which will accomplish simple tasks.,"Students will extend their understanding of software productivity tools, using revision control for group work, and be introduced to test-driven development as an integral part of software construction."
0.8821,Design a Turing Machine which will accomplish simple tasks.,"Major foci are data structures, object oriented programming, and an introduction to software engineering."
0.8842,Design a Turing Machine which will accomplish simple tasks.,This course introduces students to the fundamentals of software development with a substantial group software project at its center.
0.8848,Design a Turing Machine which will accomplish simple tasks.,"Develop, understand, test, and evolve substantial programs using a modern IDE, and associated configuration tools; understand common coding errors and how to avoid them; practice fundamental defensive programming; perform individual and team program reviews; use established design principles to organize a software system."
0.8878,Design a Turing Machine which will accomplish simple tasks.,"Use, implement, and evaluate fundamental data structures and associated algorithms; create, implement, debug, and evaluate algorithms for solving substantial problems, including recursively, using divide-and-conquer, and via decomposition; implement an abstract data type."
0.8880,Design a Turing Machine which will accomplish simple tasks.,"Apply basic algorithmic analysis to simple algorithms; use appropriate algorithmic approaches to solve problems (brute-force, divide-and-conquer, recursive backtracking, heuristic)."
0.8905,Design a Turing Machine which will accomplish simple tasks.,"Deliver and evaluate basic technical documents, presentations, and group interactions, using appropriate tools."
0.8919,Design a Turing Machine which will accomplish simple tasks.,The theory of data structures and their time and space complexity will thus be tied to the practice of using standard collections such as those offered by object oriented languages.
0.9010,Design a Turing Machine which will accomplish simple tasks.,"Understand the basics of event-driven programming, and its use in constructing GUIs"
0.9038,Design a Turing Machine which will accomplish simple tasks.,"The course includes a deeper treatment of data structures, using hash tables, trees and lists, which are used to provide concrete implementations of abstract library collection types."
0.9200,Design a Turing Machine which will accomplish simple tasks.,"Apply fundamental programming concepts, using an object oriented programming language, to solve substantial problems."
